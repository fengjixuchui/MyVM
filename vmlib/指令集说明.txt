18个指令 
不使用变长标记
说明请看头文件下方的指令执行函数说明
使用数据时只能使用数据暂存器的数据
不能直接是用暂存器组的数据
 rupt(dword id);  00 00 00 00 [中断向量id:dowrd] rupt函数和这个rupt指令不是一回事 rupt指令触发一个内部中断 中断指令执行后当前地址就已经移位到下一个指令
 外部中断则不影响当前指令指针
    leareg(dword regid,word id);  01 00 [寄存器id:dowrd][暂存器id:word]
     leamem(word id);  02 00 00 00 00 00 [暂存器id:word]


     ld(word id); 03 00 00 00 00 00 [暂存器id:word] 
     ldl(dword data);  04 00 00 00 [数据:dword]
     ldh(dword data);  05 00 00 00 [数据]
     save(word id);  06 00 00 00 00 00 [暂存器id]

     

     add(word id);  07 00 00 00 00 00 [暂存器id] //下同
     dec(word id); 08
     mul(word id); 09
     div(word id); 0A
     cmp(word id) 0B

     pause()0C 00 00 00 00 00 00 00
     step()0D 00 00 00 00 00 00 00
     jmp()0E 00 00 00 00 00 00 00
     asjmp(byte d)0F 00 00 00 00 00 00 [忽略前面6位 只考虑最后两位]
     push 10 00 00 00 00 00 00 00
     pop()11 00 00 00 00 00 00 00
	 read 12 00 00 00 [dword id]
	 write 13 00 00 00 [dword id]

	 call 14 跳转到数据暂存器存储的地址
	 ret 15
	 iret 16
	 这个用的是8字节标准指令长度设计
	 这其实是不合理的
	 可以用一个字节表示指令标准码
	 后面跟连续数据的方法编码
	 这个以后再改
	 这样设计还可以将doone这个不正常的函数
	 的大部分内容分散到具体的函数中
	 并且可以通过直接寻址调用而无需switch


	 特殊中断说明
	 指令错误 0
	 除0 1
	 端口号不存在 2
	 寄存器不存在 3
	 中断向量号超界 4


	 寄存器4是标志寄存器 最后两位是比较位
	 比较位的高位为大于指示位 低位为等于指示位
	 cmp不会设置两个位都为真